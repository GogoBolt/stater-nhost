import {
  $e,
  B2 as B,
  Be,
  C2 as C,
  Fe,
  He,
  J,
  Je,
  N2 as N,
  Q,
  Qe,
  State,
  Tr,
  V2 as V,
  We,
  X2 as X,
  Xe,
  Ye,
  Z,
  Ze,
  ar,
  cr,
  ee,
  er,
  interpret,
  ir,
  j,
  jwtDecode,
  kr,
  lr,
  nr,
  or,
  qe,
  rr,
  sr,
  toObserver,
  tr,
  ur,
  wr,
  y,
  ze
} from "./chunk-FKZAF4IP.js";

// node_modules/@nhost/vue/dist/index.esm.js
import { getCurrentInstance as ve, inject as ge, warn as fe, computed as S, unref as f, ref as I, reactive as A, toRefs as pe } from "vue";

// node_modules/@xstate/vue/es/useMachine.js
import { shallowRef } from "vue";

// node_modules/@xstate/vue/es/useInterpret.js
import { onBeforeUnmount, onMounted } from "vue";
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2))
        t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p2 in s) if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
    t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
function useInterpret(getMachine) {
  var _a = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    _a[_i - 1] = arguments[_i];
  }
  var _b = __read(_a, 2), _c = _b[0], options = _c === void 0 ? {} : _c, observerOrListener = _b[1];
  var machine = typeof getMachine === "function" ? getMachine() : getMachine;
  var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, ["context", "guards", "actions", "activities", "services", "delays", "state"]);
  var machineConfig = {
    context,
    guards,
    actions,
    activities,
    services,
    delays
  };
  var machineWithConfig = machine.withConfig(machineConfig, function() {
    return __assign(__assign({}, machine.context), context);
  });
  var service = interpret(machineWithConfig, interpreterOptions).start(rehydratedState ? State.create(rehydratedState) : void 0);
  var sub;
  onMounted(function() {
    if (observerOrListener) {
      sub = service.subscribe(toObserver(observerOrListener));
    }
  });
  onBeforeUnmount(function() {
    service.stop();
    sub === null || sub === void 0 ? void 0 : sub.unsubscribe();
  });
  return service;
}

// node_modules/@xstate/vue/es/useActor.js
import { shallowRef as shallowRef2, isRef, watch } from "vue";
function isActorWithState(actorRef) {
  return "state" in actorRef;
}
function defaultGetSnapshot(actorRef) {
  return "getSnapshot" in actorRef ? actorRef.getSnapshot() : isActorWithState(actorRef) ? actorRef.state : void 0;
}

// node_modules/@xstate/vue/es/useSelector.js
import { onMounted as onMounted2, onBeforeUnmount as onBeforeUnmount2, shallowRef as shallowRef3 } from "vue";
var defaultCompare = function(a, b) {
  return a === b;
};
function useSelector(actor, selector, compare, getSnapshot) {
  if (compare === void 0) {
    compare = defaultCompare;
  }
  if (getSnapshot === void 0) {
    getSnapshot = defaultGetSnapshot;
  }
  var selected = shallowRef3(selector(getSnapshot(actor)));
  var updateSelectedIfChanged = function(nextSelected) {
    if (!compare(selected.value, nextSelected)) {
      selected.value = nextSelected;
    }
  };
  var sub;
  onMounted2(function() {
    var initialSelected = selector(getSnapshot(actor));
    updateSelectedIfChanged(initialSelected);
    sub = actor.subscribe(function(emitted) {
      var nextSelected = selector(emitted);
      updateSelectedIfChanged(nextSelected);
    });
  });
  onBeforeUnmount2(function() {
    sub === null || sub === void 0 ? void 0 : sub.unsubscribe();
  });
  return selected;
}

// node_modules/@vueuse/shared/index.mjs
import { shallowRef as shallowRef4, watchEffect, readonly, ref, watch as watch2, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, provide, inject, isVue3, version, isRef as isRef2, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, onBeforeMount, nextTick, onBeforeUnmount as onBeforeUnmount3, onMounted as onMounted3, onUnmounted, isReactive } from "vue-demi";
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
var isClient = typeof window !== "undefined" && typeof document !== "undefined";
var isWorker = typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
var isIOS = getIsIOS();
function getIsIOS() {
  var _a, _b;
  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((_b = window == null ? void 0 : window.navigator) == null ? void 0 : _b.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));
}
function cacheStringFunction(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
var camelizeRE = /-(\w)/g;
var camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
function identity(arg) {
  return arg;
}
function toRefs(objectRef, options = {}) {
  if (!isRef2(objectRef))
    return toRefs$1(objectRef);
  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v) {
        var _a;
        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;
        if (replaceRef) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v;
            objectRef.value = copy;
          } else {
            const newObject = { ...objectRef.value, [key]: v };
            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
            objectRef.value = newObject;
          }
        } else {
          objectRef.value[key] = v;
        }
      }
    }));
  }
  return result;
}

// node_modules/@vueuse/core/index.mjs
import { isRef as isRef3, ref as ref2, shallowRef as shallowRef5, watchEffect as watchEffect2, computed as computed2, inject as inject2, isVue3 as isVue32, version as version2, defineComponent, h, TransitionGroup, shallowReactive, Fragment, watch as watch3, getCurrentInstance as getCurrentInstance2, customRef as customRef2, onUpdated, onMounted as onMounted4, isVue2 as isVue22, readonly as readonly2, nextTick as nextTick2, reactive as reactive2, markRaw, unref as unref2, getCurrentScope as getCurrentScope2, set, del, isReadonly, onBeforeUpdate } from "vue-demi";
var defaultDocument = isClient ? window.document : void 0;
var defaultNavigator = isClient ? window.navigator : void 0;
var defaultLocation = isClient ? window.location : void 0;
var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var globalKey = "__vueuse_ssr_handlers__";
var handlers = getHandlers();
function getHandlers() {
  if (!(globalKey in _global))
    _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
var defaultState = {
  x: 0,
  y: 0,
  pointerId: 0,
  pressure: 0,
  tiltX: 0,
  tiltY: 0,
  width: 0,
  height: 0,
  twist: 0,
  pointerType: null
};
var keys = Object.keys(defaultState);
var DEFAULT_UNITS = [
  { max: 6e4, value: 1e3, name: "second" },
  { max: 276e4, value: 6e4, name: "minute" },
  { max: 72e6, value: 36e5, name: "hour" },
  { max: 5184e5, value: 864e5, name: "day" },
  { max: 24192e5, value: 6048e5, name: "week" },
  { max: 28512e6, value: 2592e6, name: "month" },
  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }
];
var _TransitionPresets = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
var TransitionPresets = Object.assign({}, { linear: identity }, _TransitionPresets);

// node_modules/@nhost/vue/dist/index.esm.js
var U = Symbol("default-nhost-client");
var Se;
function E() {
  let t;
  const e = Se;
  if (!ve())
    t = () => e;
  else {
    const i = ge(U, null);
    t = () => i;
  }
  function s() {
    const i = t();
    if (!i)
      throw new Error(
        "No Nhost client found. Use provideNhostClient() if you are outside of a component setup."
      );
    return i;
  }
  return {
    resolveNhostClient: s,
    get nhost() {
      return s();
    }
  };
}
var Ae = class extends C {
  constructor(e) {
    var s;
    super({ ...e, start: true }), this.autoSignIn = (s = e.autoSignIn) != null ? s : true;
  }
  /**
   * @internal
   * This method transforms the NhostClient class into a Vue plugin
   */
  install(e) {
    const s = this.autoSignIn;
    if (e.provide(U, this), s) {
      const i = e.config.globalProperties.$router;
      if (!i)
        return;
      if (i.options.history.base) {
        fe(
          "[Nhost]: Vue-router is configured with a history Hash Mode. Refresh tokens will not be removed from the hash."
        );
        return;
      }
      i.afterEach(() => {
        Q("refreshToken"), Q("type");
      });
    }
  }
};
var p = () => {
  const { nhost: t } = E();
  return S(() => {
    const e = t.auth.client.interpreter;
    if (!e) throw Error("No interpreter");
    return e;
  });
};
var T = () => {
  const t = p();
  return useSelector(t.value, (e) => e.context.accessToken.value);
};
var C2 = () => {
  const t = p();
  return useSelector(t.value, (e) => e.matches({ authentication: "signedIn" }));
};
var Ue = () => {
  const t = p();
  return toRefs(
    useSelector(
      t.value,
      (e) => ({
        isAuthenticated: e.matches({ authentication: "signedIn" }),
        isLoading: e.hasTag("loading"),
        error: e.context.errors.authentication || null,
        isError: e.matches({ authentication: { signedOut: "failed" } }),
        connectionAttempts: e.context.importTokenAttempts
      }),
      (e, s) => e.isAuthenticated === s.isAuthenticated && e.isLoading === s.isLoading && e.connectionAttempts === s.connectionAttempts
    )
  );
};
var y2 = (t) => {
  const e = f(t);
  return Array.isArray(e) ? e.map((s) => y2(s)) : e && typeof e == "object" ? Object.entries(e).reduce(
    (s, [i, a]) => ({ ...s, [i]: y2(a) }),
    {}
  ) : e;
};
var Ce = (t) => {
  const { nhost: e } = E(), s = useInterpret($e(e.auth.client)), i = useSelector(s, (d) => d.matches("requesting")), a = useSelector(s, (d) => d.context.error), m = useSelector(s, (d) => d.matches("idle.error")), l = useSelector(s, (d) => d.matches("idle.success"));
  return { changeEmail: (d) => Fe(s, f(d), y2(t)), isLoading: i, error: a, isError: m, needsEmailVerification: l };
};
var Le = () => {
  const { nhost: t } = E(), e = useInterpret(We(t.auth.client)), s = useSelector(e, (u) => u.matches("requesting")), i = useSelector(e, (u) => u.context.error), a = useSelector(e, (u) => u.matches("idle.error")), m = useSelector(e, (u) => u.matches("idle.success"));
  return { changePassword: (u) => Be(e, f(u)), isLoading: s, error: i, isError: a, isSuccess: m };
};
var Ne = () => {
  const { nhost: t } = E(), e = useInterpret(Tr(t.auth.client)), s = useSelector(
    e,
    (o) => o.matches({ idle: "error" }) || o.matches({ generated: { idle: "error" } })
  ), i = useSelector(e, (o) => o.matches("generating")), a = useSelector(e, (o) => o.matches("generated")), m = useSelector(e, (o) => o.matches({ generated: "activating" })), l = useSelector(e, (o) => o.matches({ generated: "activated" })), u = useSelector(e, (o) => o.context.error), d = useSelector(e, (o) => o.context.imageUrl || "");
  return {
    generateQrCode: () => wr(e),
    isGenerating: i,
    qrCodeDataUrl: d,
    isGenerated: a,
    activateMfa: (o) => kr(e, f(o)),
    isActivating: m,
    isActivated: l,
    isError: s,
    error: u
  };
};
var Pe = () => {
  const t = T();
  return S(() => t.value ? jwtDecode(t.value) : null);
};
var Ie = (t) => {
  const { nhost: e } = E(), s = (g) => {
    t.send({
      type: "ADD",
      file: g.file,
      bucketId: g.bucketId || v.value
    });
  }, i = (g) => B(
    {
      url: e.storage.url,
      accessToken: e.auth.getAccessToken(),
      adminSecret: e.adminSecret,
      ...g
    },
    t
  ), a = () => {
    t.send("CANCEL");
  }, m = () => {
    t.send("DESTROY");
  }, l = useSelector(t, (g) => g.matches("uploading")), u = useSelector(t, (g) => g.matches("uploaded")), d = useSelector(t, (g) => g.matches("error")), c = useSelector(t, (g) => g.context.error || null), n = useSelector(t, (g) => g.context.progress), o = useSelector(t, (g) => g.context.id), v = useSelector(t, (g) => g.context.bucketId), h2 = useSelector(t, (g) => {
    var k;
    return (k = g.context.file) == null ? void 0 : k.name;
  });
  return {
    add: s,
    upload: i,
    cancel: a,
    destroy: m,
    isUploaded: u,
    isUploading: l,
    isError: d,
    error: c,
    progress: n,
    id: o,
    bucketId: v,
    name: h2
  };
};
var Me = () => {
  const t = useInterpret(N);
  return Ie(t);
};
var L = () => {
  const t = Pe();
  return S(() => {
    var e;
    return ((e = t.value) == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
  });
};
var Ke = (t) => {
  const e = L();
  return S(() => {
    var i;
    const s = f(t);
    return ((i = e.value) == null ? void 0 : i[s.startsWith("x-hasura-") ? s : `x-hasura-${s}`]) || null;
  });
};
var Re = () => {
  const { nhost: t } = E(), e = I([]), s = useInterpret(X, {}, (v) => {
    v.event.type === "UPLOAD_ERROR" ? e.value = v.context.files.filter((h2) => {
      var g;
      return (g = h2.getSnapshot()) == null ? void 0 : g.context.error;
    }) : (v.matches("uploaded") || v.event.type === "CLEAR") && e.value.length > 0 && (e.value = []);
  }), i = (v) => {
    s.send({ type: "ADD", ...v });
  }, a = (v) => V(
    {
      url: t.storage.url,
      accessToken: t.auth.getAccessToken(),
      adminSecret: t.adminSecret,
      ...v
    },
    s
  ), m = () => {
    s.send("CANCEL");
  }, l = () => {
    s.send("CLEAR");
  }, u = useSelector(s, (v) => v.matches("uploading")), d = useSelector(s, (v) => v.matches("uploaded")), c = useSelector(s, (v) => v.matches("error")), n = useSelector(s, (v) => v.context.progress), o = useSelector(s, (v) => v.context.files);
  return {
    upload: a,
    add: i,
    clear: l,
    cancel: m,
    progress: n,
    isUploaded: d,
    isUploading: u,
    files: o,
    isError: c,
    errors: e
  };
};
var Ve = (t) => {
  const { nhost: e } = E(), s = T();
  return A(
    new Proxy({}, {
      get(i, a) {
        const m = y2(t), l = m != null && m.connect ? { connect: s.value } : {};
        return j(
          `${e.auth.client.backendUrl}/signin/provider/${a}`,
          y(e.auth.client.clientUrl, {
            ...m,
            ...l
          })
        );
      }
    })
  );
};
var De = (t) => {
  const { nhost: e } = E(), s = useInterpret(Ye(e.auth.client)), i = useSelector(s, (d) => d.matches("requesting")), a = useSelector(s, (d) => d.matches({ idle: "success" })), m = useSelector(s, (d) => d.matches({ idle: "error" })), l = useSelector(s, (d) => d.context.error);
  return { resetPassword: (d) => ze(s, f(d), y2(t)), isLoading: i, isError: m, isSent: a, error: l };
};
var Fe2 = (t) => {
  const { nhost: e } = E(), s = useInterpret(He(e.auth.client)), i = useSelector(s, (l) => l.matches("requesting")), a = A({
    isError: false,
    error: null,
    isSent: false
  });
  return { sendEmail: (l) => Qe(s, f(l), y2(t)), isLoading: i, ...pe(a) };
};
var x = (t) => {
  const e = p();
  return useSelector(
    e.value,
    (s) => s.context.errors[t] || null,
    (s, i) => (s == null ? void 0 : s.error) === (i == null ? void 0 : i.error)
  );
};
var je = () => {
  const t = p(), e = () => Xe(t.value), s = x("authentication"), i = useSelector(
    t.value,
    (l) => l.matches({ authentication: { authenticating: "anonymous" } })
  ), a = C2(), m = useSelector(
    t.value,
    (l) => l.matches({ authentication: { signedOut: "failed" } })
  );
  return { signInAnonymous: e, isLoading: i, isSuccess: a, isError: m, error: s };
};
var $e2 = () => {
  const t = p(), e = (h2, g) => Ze(t.value, f(h2), f(g)), s = (h2) => rr(t.value, f(h2)), i = useSelector(
    t.value,
    (h2) => h2.context.user,
    (h2, g) => (h2 == null ? void 0 : h2.id) === (g == null ? void 0 : g.id)
  ), a = useSelector(t.value, (h2) => h2.context.accessToken.value), m = useSelector(t.value, (h2) => h2.context.refreshToken.value), l = x("authentication"), u = C2(), d = useSelector(
    t.value,
    (h2) => h2.matches({ authentication: { authenticating: "password" } }),
    (h2, g) => h2 === g
  ), c = useSelector(
    t.value,
    (h2) => h2.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (h2, g) => h2 === g
  ), n = useSelector(t.value, (h2) => h2.context.mfa), o = useSelector(
    t.value,
    (h2) => h2.matches({ authentication: { signedOut: "needsMfa" } }),
    (h2, g) => h2 === g
  ), v = useSelector(
    t.value,
    (h2) => h2.matches({ authentication: { signedOut: "failed" } }),
    (h2, g) => h2 === g
  );
  return {
    accessToken: a,
    refreshToken: m,
    error: l,
    isError: v,
    isLoading: d,
    isSuccess: u,
    needsEmailVerification: c,
    needsMfaOtp: o,
    mfa: n,
    sendMfaOtp: s,
    signInEmailPassword: e,
    user: i
  };
};
var qe2 = (t) => {
  const e = p(), s = (u) => Z(e.value, f(u), y2(t)), i = x("registration"), a = useSelector(
    e.value,
    (u) => u.matches("registration.passwordlessEmail")
  ), m = useSelector(
    e.value,
    (u) => u.matches("registration.incomplete.needsEmailVerification")
  ), l = useSelector(
    e.value,
    (u) => u.matches("registration.incomplete.failed")
  );
  return { signInEmailPasswordless: s, isLoading: a, isSuccess: m, isError: l, error: i };
};
var Qe2 = () => {
  const t = p(), e = (c) => nr(t.value, f(c)), s = useSelector(
    t.value,
    (c) => c.context.user,
    (c, n) => (c == null ? void 0 : c.id) === (n == null ? void 0 : n.id)
  ), i = useSelector(t.value, (c) => c.context.accessToken.value), a = useSelector(t.value, (c) => c.context.refreshToken.value), m = useSelector(
    t.value,
    (c) => c.context.errors.authentication || null,
    (c, n) => (c == null ? void 0 : c.error) === (n == null ? void 0 : n.error)
  ), l = useSelector(
    t.value,
    (c) => c.matches({ authentication: "signedIn" })
  ), u = useSelector(
    t.value,
    (c) => c.matches({ authentication: { authenticating: "password" } }),
    (c, n) => c === n
  ), d = useSelector(
    t.value,
    (c) => c.matches({ authentication: { signedOut: "failed" } }),
    (c, n) => c === n
  );
  return {
    accessToken: i,
    refreshToken: a,
    error: m,
    isError: d,
    isLoading: u,
    isSuccess: l,
    signInPAT: e,
    user: s
  };
};
function He2(t) {
  const e = p(), s = I(""), i = (n, o = t) => (s.value = f(n), J(
    e.value,
    f(n),
    y2(o)
  )), a = async (...n) => {
    if (n.length === 2) {
      const [v, h2] = n;
      return tr(e.value, f(v), f(h2));
    }
    const [o] = n;
    return tr(e.value, f(s), f(o));
  }, m = useSelector(
    e.value,
    (n) => n.context.errors.registration || null,
    (n, o) => (n == null ? void 0 : n.error) === (o == null ? void 0 : o.error)
  ), l = useSelector(
    e.value,
    (n) => n.matches("registration.passwordlessSms") || n.matches("registration.passwordlessSmsOtp")
  ), u = useSelector(e.value, (n) => n.matches("authentication.signedIn")), d = useSelector(
    e.value,
    (n) => n.matches("registration.incomplete.needsOtp")
  ), c = useSelector(
    e.value,
    (n) => n.matches("registration.incomplete.failed")
  );
  return { signInSmsPasswordless: i, sendOtp: a, isLoading: l, isSuccess: u, needsOtp: d, isError: c, error: m };
}
var _e = () => {
  const t = p(), e = (a) => sr(t.value, typeof f(a) == "boolean" ? f(a) : false), s = useSelector(
    t.value,
    (a) => a.matches({ authentication: { signedOut: "success" } })
  ), i = x("signout");
  return { signOut: e, isSuccess: s, error: i };
};
var N2 = () => {
  const t = p();
  return useSelector(
    t.value,
    (e) => e.context.user,
    (e, s) => JSON.stringify(e) === JSON.stringify(s)
  );
};
var Ge = (t) => {
  const e = p(), s = useSelector(
    e.value,
    (o) => o.matches("registration.incomplete.failed")
  ), i = x("registration"), a = useSelector(
    e.value,
    (o) => o.matches("registration.emailPassword")
  ), m = useSelector(
    e.value,
    (o) => o.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), l = useSelector(
    e.value,
    (o) => o.matches("registration.incomplete.needsEmailVerification")
  ), u = T(), d = useSelector(e.value, (o) => o.context.refreshToken.value), c = N2();
  return {
    signUpEmailPassword: (o, v, h2) => ee(e.value, f(o), f(v), {
      ...y2(t),
      ...y2(h2)
    }),
    isLoading: a,
    isSuccess: m,
    isError: s,
    error: i,
    needsEmailVerification: l,
    accessToken: u,
    refreshToken: d,
    user: c
  };
};
var Je2 = () => {
  const t = p();
  return useSelector(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.avatarUrl;
    },
    (e, s) => e === s
  );
};
var We2 = () => {
  const t = p();
  return useSelector(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.defaultRole;
    },
    (e, s) => e === s
  );
};
var Ye2 = () => {
  const t = p();
  return useSelector(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.displayName;
    },
    (e, s) => e === s
  );
};
var ze2 = () => {
  const t = p();
  return useSelector(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.email;
    },
    (e, s) => e === s
  );
};
var Be2 = () => {
  const t = p();
  return useSelector(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.id;
    },
    (e, s) => e === s
  );
};
var Xe2 = () => {
  const t = p();
  return useSelector(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.isAnonymous;
    },
    (e, s) => e === s
  );
};
var Ze2 = () => {
  const t = p();
  return useSelector(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.locale;
    },
    (e, s) => e === s
  );
};
var be = () => {
  const t = p();
  return useSelector(t.value, (e) => {
    var s;
    return e.matches("authentication.signedIn") ? ((s = e.context.user) == null ? void 0 : s.roles) || [] : [];
  });
};
var et = () => {
  const t = N2(), e = L(), { nhost: s } = E(), i = S(
    () => {
      var l, u;
      return t.value ? ((l = e.value) == null ? void 0 : l["x-hasura-auth-elevated"]) === ((u = t.value) == null ? void 0 : u.id) : false;
    }
  ), a = S(() => !!i.value);
  return {
    elevateEmailSecurityKey: (l) => er(s.auth.client, f(l)),
    elevated: a
  };
};
var tt = (t) => {
  const e = p(), s = useSelector(e.value, (o) => !!o.context.errors.registration), i = useSelector(
    e.value,
    (o) => o.context.errors.registration || null,
    (o, v) => (o == null ? void 0 : o.error) === (v == null ? void 0 : v.error)
  ), a = useSelector(e.value, (o) => o.matches("registration.securityKey")), m = useSelector(
    e.value,
    (o) => o.matches("registration.incomplete.needsEmailVerification")
  ), l = useSelector(
    e.value,
    (o) => o.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), u = (o, v = t) => ir(e.value, f(o), f(v)), d = useSelector(
    e.value,
    (o) => o.context.user,
    (o, v) => (o == null ? void 0 : o.id) === (v == null ? void 0 : v.id)
  ), c = useSelector(e.value, (o) => o.context.accessToken.value), n = useSelector(e.value, (o) => o.context.refreshToken.value);
  return {
    accessToken: c,
    refreshToken: n,
    error: i,
    isError: s,
    isLoading: a,
    isSuccess: l,
    needsEmailVerification: m,
    signUpEmailSecurityKey: u,
    user: d
  };
};
var st = () => {
  const t = p(), e = (n) => Je(t.value, f(n)), s = useSelector(
    t.value,
    (n) => n.context.user,
    (n, o) => (n == null ? void 0 : n.id) === (o == null ? void 0 : o.id)
  ), i = useSelector(t.value, (n) => n.context.accessToken.value), a = useSelector(t.value, (n) => n.context.refreshToken.value), m = useSelector(
    t.value,
    (n) => n.context.errors.authentication || null,
    (n, o) => (n == null ? void 0 : n.error) === (o == null ? void 0 : o.error)
  ), l = useSelector(
    t.value,
    (n) => n.matches({
      authentication: "signedIn"
    })
  ), u = useSelector(
    t.value,
    (n) => n.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (n, o) => n === o
  ), d = useSelector(
    t.value,
    (n) => n.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (n, o) => n === o
  ), c = useSelector(
    t.value,
    (n) => n.matches({ authentication: { signedOut: "failed" } }),
    (n, o) => n === o
  );
  return {
    accessToken: i,
    refreshToken: a,
    error: m,
    isError: c,
    isLoading: u,
    isSuccess: l,
    needsEmailVerification: d,
    signInEmailSecurityKey: e,
    user: s
  };
};
var nt = () => {
  const { nhost: t } = E(), e = I(null), s = S(() => !e), i = S(() => !!e), a = I(false);
  return { add: async (l) => {
    a.value = true;
    const u = await qe(t.auth.client, l), { error: d } = u;
    return e && (e.value = d), a.value = false, u;
  }, isLoading: a, isSuccess: s, isError: i, error: e };
};
function rt(t) {
  const e = p(), s = (c, n = t) => or(e.value, f(c), y2(n)), i = async (c, n) => ar(e.value, f(c), f(n)), a = useSelector(
    e.value,
    (c) => c.context.errors.registration || null,
    (c, n) => (c == null ? void 0 : c.error) === (n == null ? void 0 : n.error)
  ), m = useSelector(
    e.value,
    (c) => c.matches("registration.signInEmailOTP") || c.matches("registration.verifyEmailOTP")
  ), l = useSelector(e.value, (c) => c.matches("authentication.signedIn")), u = useSelector(
    e.value,
    (c) => c.matches("registration.incomplete.needsOtp")
  ), d = useSelector(
    e.value,
    (c) => c.matches("registration.incomplete.failed")
  );
  return { signInEmailOTP: s, verifyEmailOTP: i, needsOtp: u, isLoading: m, isSuccess: l, isError: d, error: a };
}
var ot = () => {
  const t = p(), e = (c, n, o) => cr(t.value, {
    provider: f(c),
    idToken: f(n),
    nonce: f(o)
  }), s = useSelector(
    t.value,
    (c) => c.context.user,
    (c, n) => (c == null ? void 0 : c.id) === (n == null ? void 0 : n.id)
  ), i = useSelector(t.value, (c) => c.context.accessToken.value), a = useSelector(t.value, (c) => c.context.refreshToken.value), m = useSelector(
    t.value,
    (c) => c.context.errors.authentication || null,
    (c, n) => (c == null ? void 0 : c.error) === (n == null ? void 0 : n.error)
  ), l = useSelector(
    t.value,
    (c) => c.matches({ authentication: "signedIn" })
  ), u = useSelector(
    t.value,
    (c) => c.matches({ authentication: { authenticating: "idToken" } }),
    (c, n) => c === n
  ), d = useSelector(
    t.value,
    (c) => c.matches({ authentication: { signedOut: "failed" } }),
    (c, n) => c === n
  );
  return {
    accessToken: i,
    refreshToken: a,
    error: m,
    isError: d,
    isLoading: u,
    isSuccess: l,
    signInIdToken: e,
    user: s
  };
};
var ct = () => {
  const { nhost: t } = E(), e = I(null), s = S(() => !e), i = S(() => !!e), a = I(false);
  return { linkIdToken: async ({ provider: l, idToken: u, nonce: d }) => {
    a.value = true;
    const c = await ur(t.auth.client, {
      provider: l,
      idToken: u,
      ...d && { nonce: d }
    }), { error: n } = c;
    return e && (e.value = n), a.value = false, c;
  }, isLoading: a, isSuccess: s, isError: i, error: e };
};
var it = () => {
  const t = p(), e = () => lr(t.value), s = useSelector(
    t.value,
    (n) => n.context.user,
    (n, o) => (n == null ? void 0 : n.id) === (o == null ? void 0 : o.id)
  ), i = useSelector(t.value, (n) => n.context.accessToken.value), a = useSelector(t.value, (n) => n.context.refreshToken.value), m = useSelector(
    t.value,
    (n) => n.context.errors.authentication || null,
    (n, o) => (n == null ? void 0 : n.error) === (o == null ? void 0 : o.error)
  ), l = useSelector(
    t.value,
    (n) => n.matches({
      authentication: "signedIn"
    })
  ), u = useSelector(
    t.value,
    (n) => n.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (n, o) => n === o
  ), d = useSelector(
    t.value,
    (n) => n.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (n, o) => n === o
  ), c = useSelector(
    t.value,
    (n) => n.matches({ authentication: { signedOut: "failed" } }),
    (n, o) => n === o
  );
  return {
    accessToken: i,
    refreshToken: a,
    error: m,
    isError: c,
    isLoading: u,
    isSuccess: l,
    needsEmailVerification: d,
    signInSecurityKey: e,
    user: s
  };
};
export {
  U as DefaultNhostClient,
  Ae as NhostClient,
  T as useAccessToken,
  nt as useAddSecurityKey,
  p as useAuthInterpreter,
  C2 as useAuthenticated,
  Ue as useAuthenticationStatus,
  Ce as useChangeEmail,
  Le as useChangePassword,
  Ne as useConfigMfa,
  Pe as useDecodedAccessToken,
  et as useElevateSecurityKeyEmail,
  Me as useFileUpload,
  Ie as useFileUploadItem,
  Ke as useHasuraClaim,
  L as useHasuraClaims,
  ct as useLinkIdToken,
  Re as useMultipleFilesUpload,
  E as useNhostClient,
  Ve as useProviderLink,
  De as useResetPassword,
  Fe2 as useSendVerificationEmail,
  je as useSignInAnonymous,
  rt as useSignInEmailOTP,
  $e2 as useSignInEmailPassword,
  qe2 as useSignInEmailPasswordless,
  st as useSignInEmailSecurityKey,
  ot as useSignInIdToken,
  Qe2 as useSignInPAT,
  it as useSignInSecurityKey,
  He2 as useSignInSmsPasswordless,
  _e as useSignOut,
  Ge as useSignUpEmailPassword,
  tt as useSignUpEmailSecurityKey,
  Je2 as useUserAvatarUrl,
  N2 as useUserData,
  We2 as useUserDefaultRole,
  Ye2 as useUserDisplayName,
  ze2 as useUserEmail,
  Be2 as useUserId,
  Xe2 as useUserIsAnonymous,
  Ze2 as useUserLocale,
  be as useUserRoles
};
//# sourceMappingURL=@nhost_vue.js.map

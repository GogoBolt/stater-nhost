import { NhostClient as M, removeParameterFromWindow as w, createChangeEmailMachine as K, changeEmailPromise as R, createChangePasswordMachine as V, changePasswordPromise as D, createEnableMfaMachine as F, generateQrCodePromise as j, activateMfaPromise as $, createFileUploadMachine as q, uploadFilePromise as Q, createMultipleFilesUploadMachine as H, uploadMultipleFilesPromise as _, encodeQueryParameters as G, rewriteRedirectTo as J, createResetPasswordMachine as W, resetPasswordPromise as Y, createSendVerificationEmailMachine as z, sendVerificationEmailPromise as B, signInAnonymousPromise as X, signInEmailPasswordPromise as Z, signInMfaTotpPromise as b, signInEmailPasswordlessPromise as ee, signInPATPromise as te, signInSmsPasswordlessPromise as se, signInSmsPasswordlessOtpPromise as O, signOutPromise as ne, signUpEmailPasswordPromise as re, elevateEmailSecurityKeyPromise as oe, signUpEmailSecurityKeyPromise as ce, signInEmailSecurityKeyPromise as ie, addSecurityKeyPromise as ae, signInEmailOTPPromise as ue, verifyEmailOTPPromise as le, signInIdTokenPromise as de, linkIdTokenPromise as me, signInSecurityKeyPromise as he } from "@nhost/nhost-js";
import { getCurrentInstance as ve, inject as ge, warn as fe, computed as S, unref as f, ref as I, reactive as A, toRefs as pe } from "vue";
import { useSelector as r, useInterpret as P } from "@xstate/vue";
import { toRefs as Ee } from "@vueuse/core";
import { jwtDecode as ye } from "jwt-decode";
const U = Symbol("default-nhost-client");
let Se;
function E() {
  let t;
  const e = Se;
  if (!ve())
    t = () => e;
  else {
    const i = ge(U, null);
    t = () => i;
  }
  function s() {
    const i = t();
    if (!i)
      throw new Error(
        "No Nhost client found. Use provideNhostClient() if you are outside of a component setup."
      );
    return i;
  }
  return {
    resolveNhostClient: s,
    get nhost() {
      return s();
    }
  };
}
class Ae extends M {
  constructor(e) {
    var s;
    super({ ...e, start: !0 }), this.autoSignIn = (s = e.autoSignIn) != null ? s : !0;
  }
  /**
   * @internal
   * This method transforms the NhostClient class into a Vue plugin
   */
  install(e) {
    const s = this.autoSignIn;
    if (e.provide(U, this), s) {
      const i = e.config.globalProperties.$router;
      if (!i)
        return;
      if (i.options.history.base) {
        fe(
          "[Nhost]: Vue-router is configured with a history Hash Mode. Refresh tokens will not be removed from the hash."
        );
        return;
      }
      i.afterEach(() => {
        w("refreshToken"), w("type");
      });
    }
  }
}
const p = () => {
  const { nhost: t } = E();
  return S(() => {
    const e = t.auth.client.interpreter;
    if (!e) throw Error("No interpreter");
    return e;
  });
}, T = () => {
  const t = p();
  return r(t.value, (e) => e.context.accessToken.value);
}, C = () => {
  const t = p();
  return r(t.value, (e) => e.matches({ authentication: "signedIn" }));
}, Ue = () => {
  const t = p();
  return Ee(
    r(
      t.value,
      (e) => ({
        isAuthenticated: e.matches({ authentication: "signedIn" }),
        isLoading: e.hasTag("loading"),
        error: e.context.errors.authentication || null,
        isError: e.matches({ authentication: { signedOut: "failed" } }),
        connectionAttempts: e.context.importTokenAttempts
      }),
      (e, s) => e.isAuthenticated === s.isAuthenticated && e.isLoading === s.isLoading && e.connectionAttempts === s.connectionAttempts
    )
  );
}, y = (t) => {
  const e = f(t);
  return Array.isArray(e) ? e.map((s) => y(s)) : e && typeof e == "object" ? Object.entries(e).reduce(
    (s, [i, a]) => ({ ...s, [i]: y(a) }),
    {}
  ) : e;
}, Ce = (t) => {
  const { nhost: e } = E(), s = P(K(e.auth.client)), i = r(s, (d) => d.matches("requesting")), a = r(s, (d) => d.context.error), m = r(s, (d) => d.matches("idle.error")), l = r(s, (d) => d.matches("idle.success"));
  return { changeEmail: (d) => R(s, f(d), y(t)), isLoading: i, error: a, isError: m, needsEmailVerification: l };
}, Le = () => {
  const { nhost: t } = E(), e = P(V(t.auth.client)), s = r(e, (u) => u.matches("requesting")), i = r(e, (u) => u.context.error), a = r(e, (u) => u.matches("idle.error")), m = r(e, (u) => u.matches("idle.success"));
  return { changePassword: (u) => D(e, f(u)), isLoading: s, error: i, isError: a, isSuccess: m };
}, Ne = () => {
  const { nhost: t } = E(), e = P(F(t.auth.client)), s = r(
    e,
    (o) => o.matches({ idle: "error" }) || o.matches({ generated: { idle: "error" } })
  ), i = r(e, (o) => o.matches("generating")), a = r(e, (o) => o.matches("generated")), m = r(e, (o) => o.matches({ generated: "activating" })), l = r(e, (o) => o.matches({ generated: "activated" })), u = r(e, (o) => o.context.error), d = r(e, (o) => o.context.imageUrl || "");
  return {
    generateQrCode: () => j(e),
    isGenerating: i,
    qrCodeDataUrl: d,
    isGenerated: a,
    activateMfa: (o) => $(e, f(o)),
    isActivating: m,
    isActivated: l,
    isError: s,
    error: u
  };
}, Pe = () => {
  const t = T();
  return S(() => t.value ? ye(t.value) : null);
}, Ie = (t) => {
  const { nhost: e } = E(), s = (g) => {
    t.send({
      type: "ADD",
      file: g.file,
      bucketId: g.bucketId || v.value
    });
  }, i = (g) => Q(
    {
      url: e.storage.url,
      accessToken: e.auth.getAccessToken(),
      adminSecret: e.adminSecret,
      ...g
    },
    t
  ), a = () => {
    t.send("CANCEL");
  }, m = () => {
    t.send("DESTROY");
  }, l = r(t, (g) => g.matches("uploading")), u = r(t, (g) => g.matches("uploaded")), d = r(t, (g) => g.matches("error")), c = r(t, (g) => g.context.error || null), n = r(t, (g) => g.context.progress), o = r(t, (g) => g.context.id), v = r(t, (g) => g.context.bucketId), h = r(t, (g) => {
    var k;
    return (k = g.context.file) == null ? void 0 : k.name;
  });
  return {
    add: s,
    upload: i,
    cancel: a,
    destroy: m,
    isUploaded: u,
    isUploading: l,
    isError: d,
    error: c,
    progress: n,
    id: o,
    bucketId: v,
    name: h
  };
}, Me = () => {
  const t = P(q);
  return Ie(t);
}, L = () => {
  const t = Pe();
  return S(() => {
    var e;
    return ((e = t.value) == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
  });
}, Ke = (t) => {
  const e = L();
  return S(() => {
    var i;
    const s = f(t);
    return ((i = e.value) == null ? void 0 : i[s.startsWith("x-hasura-") ? s : `x-hasura-${s}`]) || null;
  });
}, Re = () => {
  const { nhost: t } = E(), e = I([]), s = P(H, {}, (v) => {
    v.event.type === "UPLOAD_ERROR" ? e.value = v.context.files.filter((h) => {
      var g;
      return (g = h.getSnapshot()) == null ? void 0 : g.context.error;
    }) : (v.matches("uploaded") || v.event.type === "CLEAR") && e.value.length > 0 && (e.value = []);
  }), i = (v) => {
    s.send({ type: "ADD", ...v });
  }, a = (v) => _(
    {
      url: t.storage.url,
      accessToken: t.auth.getAccessToken(),
      adminSecret: t.adminSecret,
      ...v
    },
    s
  ), m = () => {
    s.send("CANCEL");
  }, l = () => {
    s.send("CLEAR");
  }, u = r(s, (v) => v.matches("uploading")), d = r(s, (v) => v.matches("uploaded")), c = r(s, (v) => v.matches("error")), n = r(s, (v) => v.context.progress), o = r(s, (v) => v.context.files);
  return {
    upload: a,
    add: i,
    clear: l,
    cancel: m,
    progress: n,
    isUploaded: d,
    isUploading: u,
    files: o,
    isError: c,
    errors: e
  };
}, Ve = (t) => {
  const { nhost: e } = E(), s = T();
  return A(
    new Proxy({}, {
      get(i, a) {
        const m = y(t), l = m != null && m.connect ? { connect: s.value } : {};
        return G(
          `${e.auth.client.backendUrl}/signin/provider/${a}`,
          J(e.auth.client.clientUrl, {
            ...m,
            ...l
          })
        );
      }
    })
  );
}, De = (t) => {
  const { nhost: e } = E(), s = P(W(e.auth.client)), i = r(s, (d) => d.matches("requesting")), a = r(s, (d) => d.matches({ idle: "success" })), m = r(s, (d) => d.matches({ idle: "error" })), l = r(s, (d) => d.context.error);
  return { resetPassword: (d) => Y(s, f(d), y(t)), isLoading: i, isError: m, isSent: a, error: l };
}, Fe = (t) => {
  const { nhost: e } = E(), s = P(z(e.auth.client)), i = r(s, (l) => l.matches("requesting")), a = A({
    isError: !1,
    error: null,
    isSent: !1
  });
  return { sendEmail: (l) => B(s, f(l), y(t)), isLoading: i, ...pe(a) };
}, x = (t) => {
  const e = p();
  return r(
    e.value,
    (s) => s.context.errors[t] || null,
    (s, i) => (s == null ? void 0 : s.error) === (i == null ? void 0 : i.error)
  );
}, je = () => {
  const t = p(), e = () => X(t.value), s = x("authentication"), i = r(
    t.value,
    (l) => l.matches({ authentication: { authenticating: "anonymous" } })
  ), a = C(), m = r(
    t.value,
    (l) => l.matches({ authentication: { signedOut: "failed" } })
  );
  return { signInAnonymous: e, isLoading: i, isSuccess: a, isError: m, error: s };
}, $e = () => {
  const t = p(), e = (h, g) => Z(t.value, f(h), f(g)), s = (h) => b(t.value, f(h)), i = r(
    t.value,
    (h) => h.context.user,
    (h, g) => (h == null ? void 0 : h.id) === (g == null ? void 0 : g.id)
  ), a = r(t.value, (h) => h.context.accessToken.value), m = r(t.value, (h) => h.context.refreshToken.value), l = x("authentication"), u = C(), d = r(
    t.value,
    (h) => h.matches({ authentication: { authenticating: "password" } }),
    (h, g) => h === g
  ), c = r(
    t.value,
    (h) => h.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (h, g) => h === g
  ), n = r(t.value, (h) => h.context.mfa), o = r(
    t.value,
    (h) => h.matches({ authentication: { signedOut: "needsMfa" } }),
    (h, g) => h === g
  ), v = r(
    t.value,
    (h) => h.matches({ authentication: { signedOut: "failed" } }),
    (h, g) => h === g
  );
  return {
    accessToken: a,
    refreshToken: m,
    error: l,
    isError: v,
    isLoading: d,
    isSuccess: u,
    needsEmailVerification: c,
    needsMfaOtp: o,
    mfa: n,
    sendMfaOtp: s,
    signInEmailPassword: e,
    user: i
  };
}, qe = (t) => {
  const e = p(), s = (u) => ee(e.value, f(u), y(t)), i = x("registration"), a = r(
    e.value,
    (u) => u.matches("registration.passwordlessEmail")
  ), m = r(
    e.value,
    (u) => u.matches("registration.incomplete.needsEmailVerification")
  ), l = r(
    e.value,
    (u) => u.matches("registration.incomplete.failed")
  );
  return { signInEmailPasswordless: s, isLoading: a, isSuccess: m, isError: l, error: i };
}, Qe = () => {
  const t = p(), e = (c) => te(t.value, f(c)), s = r(
    t.value,
    (c) => c.context.user,
    (c, n) => (c == null ? void 0 : c.id) === (n == null ? void 0 : n.id)
  ), i = r(t.value, (c) => c.context.accessToken.value), a = r(t.value, (c) => c.context.refreshToken.value), m = r(
    t.value,
    (c) => c.context.errors.authentication || null,
    (c, n) => (c == null ? void 0 : c.error) === (n == null ? void 0 : n.error)
  ), l = r(
    t.value,
    (c) => c.matches({ authentication: "signedIn" })
  ), u = r(
    t.value,
    (c) => c.matches({ authentication: { authenticating: "password" } }),
    (c, n) => c === n
  ), d = r(
    t.value,
    (c) => c.matches({ authentication: { signedOut: "failed" } }),
    (c, n) => c === n
  );
  return {
    accessToken: i,
    refreshToken: a,
    error: m,
    isError: d,
    isLoading: u,
    isSuccess: l,
    signInPAT: e,
    user: s
  };
};
function He(t) {
  const e = p(), s = I(""), i = (n, o = t) => (s.value = f(n), se(
    e.value,
    f(n),
    y(o)
  )), a = async (...n) => {
    if (n.length === 2) {
      const [v, h] = n;
      return O(e.value, f(v), f(h));
    }
    const [o] = n;
    return O(e.value, f(s), f(o));
  }, m = r(
    e.value,
    (n) => n.context.errors.registration || null,
    (n, o) => (n == null ? void 0 : n.error) === (o == null ? void 0 : o.error)
  ), l = r(
    e.value,
    (n) => n.matches("registration.passwordlessSms") || n.matches("registration.passwordlessSmsOtp")
  ), u = r(e.value, (n) => n.matches("authentication.signedIn")), d = r(
    e.value,
    (n) => n.matches("registration.incomplete.needsOtp")
  ), c = r(
    e.value,
    (n) => n.matches("registration.incomplete.failed")
  );
  return { signInSmsPasswordless: i, sendOtp: a, isLoading: l, isSuccess: u, needsOtp: d, isError: c, error: m };
}
const _e = () => {
  const t = p(), e = (a) => ne(t.value, typeof f(a) == "boolean" ? f(a) : !1), s = r(
    t.value,
    (a) => a.matches({ authentication: { signedOut: "success" } })
  ), i = x("signout");
  return { signOut: e, isSuccess: s, error: i };
}, N = () => {
  const t = p();
  return r(
    t.value,
    (e) => e.context.user,
    (e, s) => JSON.stringify(e) === JSON.stringify(s)
  );
}, Ge = (t) => {
  const e = p(), s = r(
    e.value,
    (o) => o.matches("registration.incomplete.failed")
  ), i = x("registration"), a = r(
    e.value,
    (o) => o.matches("registration.emailPassword")
  ), m = r(
    e.value,
    (o) => o.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), l = r(
    e.value,
    (o) => o.matches("registration.incomplete.needsEmailVerification")
  ), u = T(), d = r(e.value, (o) => o.context.refreshToken.value), c = N();
  return {
    signUpEmailPassword: (o, v, h) => re(e.value, f(o), f(v), {
      ...y(t),
      ...y(h)
    }),
    isLoading: a,
    isSuccess: m,
    isError: s,
    error: i,
    needsEmailVerification: l,
    accessToken: u,
    refreshToken: d,
    user: c
  };
}, Je = () => {
  const t = p();
  return r(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.avatarUrl;
    },
    (e, s) => e === s
  );
}, We = () => {
  const t = p();
  return r(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.defaultRole;
    },
    (e, s) => e === s
  );
}, Ye = () => {
  const t = p();
  return r(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.displayName;
    },
    (e, s) => e === s
  );
}, ze = () => {
  const t = p();
  return r(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.email;
    },
    (e, s) => e === s
  );
}, Be = () => {
  const t = p();
  return r(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.id;
    },
    (e, s) => e === s
  );
}, Xe = () => {
  const t = p();
  return r(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.isAnonymous;
    },
    (e, s) => e === s
  );
}, Ze = () => {
  const t = p();
  return r(
    t.value,
    (e) => {
      var s;
      return (s = e.context.user) == null ? void 0 : s.locale;
    },
    (e, s) => e === s
  );
}, be = () => {
  const t = p();
  return r(t.value, (e) => {
    var s;
    return e.matches("authentication.signedIn") ? ((s = e.context.user) == null ? void 0 : s.roles) || [] : [];
  });
}, et = () => {
  const t = N(), e = L(), { nhost: s } = E(), i = S(
    () => {
      var l, u;
      return t.value ? ((l = e.value) == null ? void 0 : l["x-hasura-auth-elevated"]) === ((u = t.value) == null ? void 0 : u.id) : !1;
    }
  ), a = S(() => !!i.value);
  return {
    elevateEmailSecurityKey: (l) => oe(s.auth.client, f(l)),
    elevated: a
  };
}, tt = (t) => {
  const e = p(), s = r(e.value, (o) => !!o.context.errors.registration), i = r(
    e.value,
    (o) => o.context.errors.registration || null,
    (o, v) => (o == null ? void 0 : o.error) === (v == null ? void 0 : v.error)
  ), a = r(e.value, (o) => o.matches("registration.securityKey")), m = r(
    e.value,
    (o) => o.matches("registration.incomplete.needsEmailVerification")
  ), l = r(
    e.value,
    (o) => o.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), u = (o, v = t) => ce(e.value, f(o), f(v)), d = r(
    e.value,
    (o) => o.context.user,
    (o, v) => (o == null ? void 0 : o.id) === (v == null ? void 0 : v.id)
  ), c = r(e.value, (o) => o.context.accessToken.value), n = r(e.value, (o) => o.context.refreshToken.value);
  return {
    accessToken: c,
    refreshToken: n,
    error: i,
    isError: s,
    isLoading: a,
    isSuccess: l,
    needsEmailVerification: m,
    signUpEmailSecurityKey: u,
    user: d
  };
}, st = () => {
  const t = p(), e = (n) => ie(t.value, f(n)), s = r(
    t.value,
    (n) => n.context.user,
    (n, o) => (n == null ? void 0 : n.id) === (o == null ? void 0 : o.id)
  ), i = r(t.value, (n) => n.context.accessToken.value), a = r(t.value, (n) => n.context.refreshToken.value), m = r(
    t.value,
    (n) => n.context.errors.authentication || null,
    (n, o) => (n == null ? void 0 : n.error) === (o == null ? void 0 : o.error)
  ), l = r(
    t.value,
    (n) => n.matches({
      authentication: "signedIn"
    })
  ), u = r(
    t.value,
    (n) => n.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (n, o) => n === o
  ), d = r(
    t.value,
    (n) => n.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (n, o) => n === o
  ), c = r(
    t.value,
    (n) => n.matches({ authentication: { signedOut: "failed" } }),
    (n, o) => n === o
  );
  return {
    accessToken: i,
    refreshToken: a,
    error: m,
    isError: c,
    isLoading: u,
    isSuccess: l,
    needsEmailVerification: d,
    signInEmailSecurityKey: e,
    user: s
  };
}, nt = () => {
  const { nhost: t } = E(), e = I(null), s = S(() => !e), i = S(() => !!e), a = I(!1);
  return { add: async (l) => {
    a.value = !0;
    const u = await ae(t.auth.client, l), { error: d } = u;
    return e && (e.value = d), a.value = !1, u;
  }, isLoading: a, isSuccess: s, isError: i, error: e };
};
function rt(t) {
  const e = p(), s = (c, n = t) => ue(e.value, f(c), y(n)), i = async (c, n) => le(e.value, f(c), f(n)), a = r(
    e.value,
    (c) => c.context.errors.registration || null,
    (c, n) => (c == null ? void 0 : c.error) === (n == null ? void 0 : n.error)
  ), m = r(
    e.value,
    (c) => c.matches("registration.signInEmailOTP") || c.matches("registration.verifyEmailOTP")
  ), l = r(e.value, (c) => c.matches("authentication.signedIn")), u = r(
    e.value,
    (c) => c.matches("registration.incomplete.needsOtp")
  ), d = r(
    e.value,
    (c) => c.matches("registration.incomplete.failed")
  );
  return { signInEmailOTP: s, verifyEmailOTP: i, needsOtp: u, isLoading: m, isSuccess: l, isError: d, error: a };
}
const ot = () => {
  const t = p(), e = (c, n, o) => de(t.value, {
    provider: f(c),
    idToken: f(n),
    nonce: f(o)
  }), s = r(
    t.value,
    (c) => c.context.user,
    (c, n) => (c == null ? void 0 : c.id) === (n == null ? void 0 : n.id)
  ), i = r(t.value, (c) => c.context.accessToken.value), a = r(t.value, (c) => c.context.refreshToken.value), m = r(
    t.value,
    (c) => c.context.errors.authentication || null,
    (c, n) => (c == null ? void 0 : c.error) === (n == null ? void 0 : n.error)
  ), l = r(
    t.value,
    (c) => c.matches({ authentication: "signedIn" })
  ), u = r(
    t.value,
    (c) => c.matches({ authentication: { authenticating: "idToken" } }),
    (c, n) => c === n
  ), d = r(
    t.value,
    (c) => c.matches({ authentication: { signedOut: "failed" } }),
    (c, n) => c === n
  );
  return {
    accessToken: i,
    refreshToken: a,
    error: m,
    isError: d,
    isLoading: u,
    isSuccess: l,
    signInIdToken: e,
    user: s
  };
}, ct = () => {
  const { nhost: t } = E(), e = I(null), s = S(() => !e), i = S(() => !!e), a = I(!1);
  return { linkIdToken: async ({ provider: l, idToken: u, nonce: d }) => {
    a.value = !0;
    const c = await me(t.auth.client, {
      provider: l,
      idToken: u,
      ...d && { nonce: d }
    }), { error: n } = c;
    return e && (e.value = n), a.value = !1, c;
  }, isLoading: a, isSuccess: s, isError: i, error: e };
}, it = () => {
  const t = p(), e = () => he(t.value), s = r(
    t.value,
    (n) => n.context.user,
    (n, o) => (n == null ? void 0 : n.id) === (o == null ? void 0 : o.id)
  ), i = r(t.value, (n) => n.context.accessToken.value), a = r(t.value, (n) => n.context.refreshToken.value), m = r(
    t.value,
    (n) => n.context.errors.authentication || null,
    (n, o) => (n == null ? void 0 : n.error) === (o == null ? void 0 : o.error)
  ), l = r(
    t.value,
    (n) => n.matches({
      authentication: "signedIn"
    })
  ), u = r(
    t.value,
    (n) => n.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (n, o) => n === o
  ), d = r(
    t.value,
    (n) => n.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (n, o) => n === o
  ), c = r(
    t.value,
    (n) => n.matches({ authentication: { signedOut: "failed" } }),
    (n, o) => n === o
  );
  return {
    accessToken: i,
    refreshToken: a,
    error: m,
    isError: c,
    isLoading: u,
    isSuccess: l,
    needsEmailVerification: d,
    signInSecurityKey: e,
    user: s
  };
};
export {
  U as DefaultNhostClient,
  Ae as NhostClient,
  T as useAccessToken,
  nt as useAddSecurityKey,
  p as useAuthInterpreter,
  C as useAuthenticated,
  Ue as useAuthenticationStatus,
  Ce as useChangeEmail,
  Le as useChangePassword,
  Ne as useConfigMfa,
  Pe as useDecodedAccessToken,
  et as useElevateSecurityKeyEmail,
  Me as useFileUpload,
  Ie as useFileUploadItem,
  Ke as useHasuraClaim,
  L as useHasuraClaims,
  ct as useLinkIdToken,
  Re as useMultipleFilesUpload,
  E as useNhostClient,
  Ve as useProviderLink,
  De as useResetPassword,
  Fe as useSendVerificationEmail,
  je as useSignInAnonymous,
  rt as useSignInEmailOTP,
  $e as useSignInEmailPassword,
  qe as useSignInEmailPasswordless,
  st as useSignInEmailSecurityKey,
  ot as useSignInIdToken,
  Qe as useSignInPAT,
  it as useSignInSecurityKey,
  He as useSignInSmsPasswordless,
  _e as useSignOut,
  Ge as useSignUpEmailPassword,
  tt as useSignUpEmailSecurityKey,
  Je as useUserAvatarUrl,
  N as useUserData,
  We as useUserDefaultRole,
  Ye as useUserDisplayName,
  ze as useUserEmail,
  Be as useUserId,
  Xe as useUserIsAnonymous,
  Ze as useUserLocale,
  be as useUserRoles
};
//# sourceMappingURL=index.esm.js.map
